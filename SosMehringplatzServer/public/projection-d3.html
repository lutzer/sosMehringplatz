<!doctype html>
<html>
	<head>
	<title>Test Client</title>
	<script src="//code.jquery.com/jquery-1.11.3.min.js"></script>
	<script src="libs/socket.io.js"></script>
	<script src="libs/d3.min.js"></script>
	<style type="text/css">

		circle {
		 	stroke: #000;
			stroke-opacity: 0.5;
		}

	</style>
	<script>

		/* SERVER COMMUNICATION */

		var socket = io();
		var addSubmission = function(submission) {
			//$('#messages').append('<li>'+submission._id+':'+submission.content+'</li>');
		};

		socket.on('connect', function() {
			console.log('socket connected');

			//get initial list
			socket.emit('submissions:list'); 
		});

		socket.on('submissions:added', function(res) {
			addSubmission(res.data);
		});

		// only load the initial list once
		socket.once('submissions:list', function(res) {
			res.data.forEach( function(elem) {
				addSubmission(elem);
			});
		});
	</script>
	</head>
	<body>
		<div id="body">
    	</div>
    	<script>

    		var w = window.innerWidth,
                h = window.innerHeight,
                color = ['#aa0000','#00aa00','#0000aa'];
            var counter = 99;

            var nodes = d3.range(5).map(function() { return {radius: Math.random() * 12 + 4}; });

            var force = d3.layout.force()
                .gravity(0.05)
                .charge(function(d, i) { return i ? 0 : +500; })
                .nodes(nodes)
                .size([w, h]);

            var root = nodes[0];
            root.radius = 0;
            root.px = w/2;
            root.py = h/2;
            root.fixed = true;

            force.start();

            var svg = d3.select("#body").append("svg:svg")
                .attr("width", w)
                .attr("height", h);

            svg.selectAll("circle")
                .data(nodes.slice(1))
                .enter().append("svg:circle")
                .attr("r", function(d) { return d.radius - 2; })
                .style("fill", function(d, i) { return color[i % 3]; })
                .attr("class", "node");

            // on mouseclick add new node
            svg.on("click", function() {
                var p = d3.mouse(this);
                addNode({
                  radius: 100,
                  weight: 100,
                  x: p[0],
                  y: p[1],
                  id: 'test'+counter++
                });
            })

            function addNode(newNode) {
                nodes.push(newNode);

                node = svg.selectAll(".node")
                    .data(force.nodes(), function(d) { return d.id;});
                node.enter()
                    .append("circle")
                    .attr("class", "node")
                    .attr("r", 30)
                    .style("fill", color[1]);

                //node.exit().remove();

                force.start();
            }

            /*svg.on("mousemove", function() {
              var p1 = d3.svg.mouse(this);
              root.px = p1[0];
              root.py = p1[1];
              force.resume();
            });*/

            force.on("tick", function(e) {
                var q = d3.geom.quadtree(nodes),
                    i = 0,
                    n = nodes.length;

                //check collisions
                while (++i < n) {
                    q.visit(collide(nodes[i]));
                }

                //update positions
                svg.selectAll("circle")
                    .attr("cx", function(d) { return d.x; })
                    .attr("cy", function(d) { return d.y; });
            });

            function collide(node) {
              var r = node.radius + 16,
                  nx1 = node.x - r,
                  nx2 = node.x + r,
                  ny1 = node.y - r,
                  ny2 = node.y + r;
              return function(quad, x1, y1, x2, y2) {
                if (quad.point && (quad.point !== node)) {
                  var x = node.x - quad.point.x,
                      y = node.y - quad.point.y,
                      l = Math.sqrt(x * x + y * y),
                      r = node.radius + quad.point.radius;
                  if (l < r) {
                    l = (l - r) / l * .5;
                    node.x -= x *= l;
                    node.y -= y *= l;
                    quad.point.x += x;
                    quad.point.y += y;
                  }
                }
                return x1 > nx2
                    || x2 < nx1
                    || y1 > ny2
                    || y2 < ny1;
              };
            }

    	</script>
	</body>
</html>